#### 基础题

1. 说几种div垂直水平居中的方式

  ```css
  /* 不定宽高的居中 */
  div{
      position: absolute;
      left:50%;
      top:50%;
      transform: translate(-50%, -50%);
  }
  div{
      display:flex;
      align-items:center;
      justify-content:center;
  }
  ```

  ```css
  /* 固定宽高的居中 */
  div{
    	width: 100px;
    	height: 100px;
      position: absolute;
      left:50%;
      top:50%;
      margin-top: -50px;
    	margin-left: -50px;
  }
  div{
    width: 100px;
    height: 100px;
    position:absolute;
    left:0;
    top: 0;
    bottom: 0;
    right: 0;
    margin: auto;
  }
  ```

2. 判断数据类型的方式有几种？分别在什么情况下用?
   有两种**typeof**和**Object.prototype.toString.call()**
   typeof用于基本类型的判断，Object.prototype.toString.call()用于引用类型的判断

  

3. 怎么解决跨域问题
   CORS，反向代理，postMessage



#### VUE
1. 组件之间的传参方式用过哪几种
    props/emit

    vuex
    
    eventBus
    
    provide/inject
    
    $parent/$children
    
    插槽
    
    https://segmentfault.com/a/1190000017357320?utm_source=tag-newest
    
    
    
2. 生命周期钩子函数有哪几个,分别用在什么地方

  beforeCreate和created

  beforeMount和mounted

  beforeUpdate和updated

  beforeDestroy和destroyed



3. vuex存取数据的流程
     1. 通过new Vuex.Store()创建一个仓库 state是公共的状态，state--->components渲染页面
     2. 在组件内部通过this.$store.state.属性 来调用公共状态中的state，进行页面的渲染。
     3. 当组件需要修改数据的时候，必须遵循单向数据流。通过this.$store.dispatch来触发actions中的方法
     4. actions中的每个方法都会接受一个对象 这个对象里面有一个commit方法，用来触发mutations里面的方法
     5. mutations里面的方法用来修改state中的数据 mutations里面的方法都会接收到2个参数 一个是store中的state
     6. 当mutations中的方法执行完毕后state会发生改变，因为vuex的数据是响应式的 所以组件的状态也会发生改变

4. mixin的优缺点

   


#### 业务相关

1. 防抖与节流的区别

  防抖与节流函数是一种最常用的 **高频触发优化方式**，能对性能有较大的帮助。

  - **防抖 (debounce)**: 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。

  ```js
  function debounce(fn, wait, immediate) {
      let timer = null
  
      return function() {
          let args = arguments
          let context = this
  
          if (immediate && !timer) {
              fn.apply(context, args)
          }
  
          if (timer) clearTimeout(timer)
          timer = setTimeout(() => {
              fn.apply(context, args)
          }, wait)
      }
  }
  ```

  - **节流(throttle)**: 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。

  ```js
  function throttle(fn, wait, immediate) {
      let timer = null
      let callNow = immediate
      
      return function() {
          let context = this,
              args = arguments
  
          if (callNow) {
              fn.apply(context, args)
              callNow = false
          }
  
          if (!timer) {
              timer = setTimeout(() => {
                  fn.apply(context, args)
                  timer = null
              }, wait)
          }
      }
  }
  ```

2. 代码的复用

当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:

- 函数封装
- 继承
- 复制`extend`
- 混入`mixin`
- 借用`apply/call`



3. 菜单权限的前端实现
4. mixin



### 工作态度、主动



微任务、宏任务

promise.then实现

loader和plugin

